// These are the interfaces for all the states in this game
import { IBaseGame, IBaseGameObject, IBasePlayer } from "@cadre/ts-utils/cadre";

// This is a file generated by the Creer, it may have empty interfaces,
// but we need them, so let's disable that tslint rule
// tslint:disable:no-empty-interface

/**
 * Send hordes of the undead at your opponent while defending yourself against
 * theirs to win.
 */
export interface IGameState extends IBaseGame {
    /**
     * The player whose turn it is currently. That player can send commands.
     * Other players cannot.
     */
    currentPlayer: IPlayerState;

    /**
     * The current turn number, starting at 0 for the first player's turn.
     */
    currentTurn: number;

    /**
     * A mapping of every game object's ID to the actual game object. Primarily
     * used by the server and client to easily refer to the game objects via ID.
     */
    gameObjects: {[id: string]: IGameObjectState};

    /**
     * The amount of gold income per turn per unit in a mine.
     */
    goldIncomePerUnit: number;

    /**
     * The amount of gold income per turn per unit in the island mine.
     */
    islandIncomePerUnit: number;

    /**
     * The Amount of gold income per turn per unit fishing on the river side.
     */
    manaIncomePerUnit: number;

    /**
     * The number of Tiles in the map along the y (vertical) axis.
     */
    mapHeight: number;

    /**
     * The number of Tiles in the map along the x (horizontal) axis.
     */
    mapWidth: number;

    /**
     * The maximum number of turns before the game will automatically end.
     */
    maxTurns: number;

    /**
     * List of all the players in the game.
     */
    players: IPlayerState[];

    /**
     * The amount of turns it takes between the river changing phases.
     */
    riverPhase: number;

    /**
     * A unique identifier for the game instance that is being played.
     */
    session: string;

    /**
     * A list of every tower type / job.
     */
    tJobs: tJob[];

    /**
     * All the tiles in the map, stored in Row-major order. Use `x + y *
     * mapWidth` to access the correct index.
     */
    tiles: ITileState[];

    /**
     * The amount of time (in nano-seconds) added after each player performs a
     * turn.
     */
    timeAddedPerTurn: number;

    /**
     * Every Tower in the game.
     */
    towers: ITowerState[];

    /**
     * A list of every unit type / job.
     */
    uJobs: uJob[];

    /**
     * Every Unit in the game.
     */
    units: IUnitState[];

}

/**
 * An object in the game. The most basic class that all game classes should
 * inherit from automatically.
 */
export interface IGameObjectState extends IBaseGameObject {
    /**
     * String representing the top level Class that this game object is an
     * instance of. Used for reflection to create new instances on clients, but
     * exposed for convenience should AIs want this data.
     */
    gameObjectName: string;

    /**
     * A unique id for each instance of a GameObject or a sub class. Used for
     * client and server communication. Should never change value after being
     * set.
     */
    id: string;

    /**
     * Any strings logged will be stored here. Intended for debugging.
     */
    logs: string[];

}

/**
 * A player in this game. Every AI controls one player.
 */
export interface IPlayerState extends IGameObjectState, IBasePlayer {
    /**
     * What type of client this is, e.g. 'Python', 'JavaScript', or some other
     * language. For potential data mining purposes.
     */
    clientType: string;

    /**
     * The amount of gold this Player has.
     */
    gold: number;

    /**
     * The amount of health remaining for this player's main unit.
     */
    health: number;

    /**
     * The tile that the home base is located on.
     */
    homeBase: ITileState[];

    /**
     * If the player lost the game or not.
     */
    lost: boolean;

    /**
     * The amount of mana this player has.
     */
    mana: number;

    /**
     * The name of the player.
     */
    name: string;

    /**
     * This player's opponent in the game.
     */
    opponent: IPlayerState;

    /**
     * The reason why the player lost the game.
     */
    reasonLost: string;

    /**
     * The reason why the player won the game.
     */
    reasonWon: string;

    /**
     * All tiles that this player can build on and move workers on.
     */
    side: ITileState[];

    /**
     * The amount of time (in ns) remaining for this AI to send commands.
     */
    timeRemaining: number;

    /**
     * Every Tower owned by this player.
     */
    towers: ITowerState[];

    /**
     * Every Unit owned by this Player.
     */
    units: IUnitState[];

    /**
     * If the player won the game or not.
     */
    won: boolean;

}

/**
 * A Tile in the game that makes up the 2D map grid.
 */
export interface ITileState extends IGameObjectState {
    /**
     * The amount of corpses on this tile.
     */
    corpses: number;

    /**
     * Whether or not the tile is a castle tile.
     */
    isCastle: boolean;

    /**
     * Whether or not the tile is considered to be a gold mine or not.
     */
    isGoldMine: boolean;

    /**
     * Whether or not the tile is considered grass or not (Workers can walk on
     * grass).
     */
    isGrass: boolean;

    /**
     * Whether or not the tile is considered to be the island gold mine or not.
     */
    isIslandGoldMine: boolean;

    /**
     * Whether or not the tile is considered a path or not (Units can walk on
     * paths).
     */
    isPath: boolean;

    /**
     * Whether or not the tile is considered a river or not.
     */
    isRiver: boolean;

    /**
     * Whether or not the tile is considered a tower or not.
     */
    isTower: boolean;

    /**
     * Whether or not the tile is the unit spawn.
     */
    isUnitSpawn: boolean;

    /**
     * Whether or not the tile can be moved on by workers.
     */
    isWall: boolean;

    /**
     * Whether or not the tile is the worker spawn.
     */
    isWorkerSpawn: boolean;

    /**
     * The amount of Ghouls on this tile.
     */
    numGhouls: number;

    /**
     * The amount of Hounds on this tile.
     */
    numHounds: number;

    /**
     * The amount of Zombies on this tile.
     */
    numZombies: number;

    /**
     * The Tile to the 'East' of this one (x+1, y). Null if out of bounds of the
     * map.
     */
    tileEast: ITileState;

    /**
     * The Tile to the 'North' of this one (x, y-1). Null if out of bounds of
     * the map.
     */
    tileNorth: ITileState;

    /**
     * The Tile to the 'South' of this one (x, y+1). Null if out of bounds of
     * the map.
     */
    tileSouth: ITileState;

    /**
     * The Tile to the 'West' of this one (x-1, y). Null if out of bounds of the
     * map.
     */
    tileWest: ITileState;

    /**
     * The Tower on this Tile if present, otherwise null.
     */
    tower: ITowerState;

    /**
     * The type of Tile this is ('normal', 'path', 'river', or 'spawn').
     */
    type: string;

    /**
     * The Unit on this Tile if present, otherwise null.
     */
    unit: IUnitState;

    /**
     * The x (horizontal) position of this Tile.
     */
    x: number;

    /**
     * The y (vertical) position of this Tile.
     */
    y: number;

}

/**
 * A tower in the game. Used to combat enemy waves.
 */
export interface ITowerState extends IGameObjectState {
    /**
     * Whether this tower has attacked this turn or not.
     */
    attacked: boolean;

    /**
     * How much remaining health this tower has.
     */
    health: number;

    /**
     * The player that built / owns this tower.
     */
    owner: IPlayerState;

    /**
     * The Tile this Tower is on.
     */
    tile: ITileState;

    /**
     * What type of tower this is (it's job).
     */
    type: tJob;

}

/**
 * A unit in the game. May be a worker, zombie, ghoul, hound, abomination,
 * wraith or horseman.
 */
export interface IUnitState extends IGameObjectState {
    /**
     * Whether or not this Unit has performed its action this turn (attack or
     * build).
     */
    acted: boolean;

    /**
     * The remaining health of a unit.
     */
    health: number;

    /**
     * The number of moves this unit has left this turn.
     */
    moves: number;

    /**
     * The Player that owns and can control this Unit.
     */
    owner: IPlayerState;

    /**
     * The Tile this Unit is on.
     */
    tile: ITileState;

    /**
     * The type of unit this is.
     */
    uJob: uJob;

}

/**
 * Information about a tower's job/type.
 */
export interface ItJobState extends IGameObjectState {
    /**
     * Whether this tower type hits all of the units on a tile (true) or one at
     * a time (false).
     */
    allUnits: boolean;

    /**
     * The amount of damage this type does per attack.
     */
    damage: number;

    /**
     * How much does this type cost in gold.
     */
    goldCost: number;

    /**
     * The amount of starting health this type has.
     */
    health: number;

    /**
     * How much does this type cost in mana.
     */
    manaCost: number;

    /**
     * The number of tiles this type can attack from.
     */
    range: number;

    /**
     * The type title. 'arrow', 'aoe', 'ballista', or 'cleansing'.
     */
    title: string;

    /**
     * How many turns have to take place between this type's attacks.
     */
    turnsBetweenAttacks: number;

}

/**
 * Information about a unit's job/type.
 */
export interface IuJobState extends IGameObjectState {
    /**
     * The amount of damage this type does per attack.
     */
    damage: number;

    /**
     * How much does this type cost in gold.
     */
    goldCost: number;

    /**
     * The amount of starting health this type has.
     */
    health: number;

    /**
     * How much does this type cost in mana.
     */
    manaCost: number;

    /**
     * The number of moves this type can make per turn.
     */
    moves: number;

    /**
     * How many of this type of unit can take up one tile.
     */
    perTile: number;

    /**
     * Amount of tiles away this type has to be in order to be effective.
     */
    range: number;

    /**
     * The type title. 'worker', 'zombie', 'ghoul', 'hound', 'abomination',
     * 'wraith' or 'horseman'.
     */
    title: string;

}
